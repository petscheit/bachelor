\documentclass[../../thesis.tex]{subfiles}
\graphicspath{{\subfix{diagrams/}}}

\begin{document}
The goal of the work is to explore if zk-rollups can be used to aggregate Uniswap trades in an effective manner. The prototype is able to aggregate trades for a single trading pair, Ether and an ERC-20 token of choice. The system consists of two main entites that are required for it to function. The first entity to look at, is the on-chain entity, we call zkSwap. zkSwap is a smart-contract deployed on the Ethereum blockchain and has three main jobs, processing deposits and withdraws, aswell as verifying batched trades. It holds users funds and exposes the on-chain functionality, namely deposits and withdrawls, to the user. 

The second entity to look at is the aggregator. The aggregator consists numerous systems, both off-chain and on-chain, and is mainly tasked with receiving trade orders, aggregating and executing them, and then verifying them with the zkSwap contract. The aggregator stores a merkle-tree of users balances and keeps it in sync by listening for event emitted by the zkSwap contract.

\begin{figure}[h]
    \centerline{\includegraphics[totalheight=8cm]{diagrams/architecture.png}}
    \caption{High level architecture of the system}
    \label{fig:architecture}
\end{figure}


\subsection{zkSwap Contract}
The zkSwap contract, is the core entity the user interacts with. Its a smart-contract, that from the users perspective, is mainly used for depositing and withdrawing funds in out system. 

\subsubsection{Storing and Updating Balances} \label{balances}
Two main factors are dictating the way balances are stored in the system. It is important to understand the core technique used to store and update balances before we look at the different functions that trigger them. We want to make balance updates as cheap as possible, while not relying on any external data availability. Essentially, this means that we need to store the balances on-chain. Storing data on-chain is typically very expensive. It is important to make a distinction between storing data in a smart-contracts runtime\todo{is runtime the correct word?} and storing data in the event log. Both are on-chain, the event log is significantly cheaper though. While the event log is cheap to use and can be queried by any client, it is not accesible to a smart-contracts runtime. This solves the external data availablity problem. We can store balances cheaply, without relying on other systems to stay online. A client can query the event log, gather the required data and pass it as parameters to the transaction. However, we now need a mechansism to ensure, the parameters passed are equal to the parameters found in the event log. 

We can achive this, be using a merkle tree \cite{szydlo2004merkle}. Merkle trees are a suitable data structure, as its root represents the entire tree state in a highly compressed form, while proving a leafs inclusion in the tree can be done with O(log n). This is ideal for our use-case. Every balance is stored as a leaf in a merkle tree, running in layer-2. The merkle tree is built and kept in sync by subscribing to the `BalanceUpdate' event emitted by our smart-contract. A client can query balances from this tree, receiving the valid merkle path along with the balance object. Since the smart-contract stores the root of the balance merkle tree in its runtime, it can verify the correctness of the passed balance by hashing it along with the provided merkle path. If the resulting hash is equal to the stored root, the correctness of the balance is proven.\todo{Should I explain on what security assumptions this is based} Any changes in the balance object by the client will result in the hashes to mismatch, thereby invalidating the data. While the hashing of the balances and merkle path does create some fixed, overhead cost, the savings by using the event log far outstrip it. The hashing costs will be analysed in S. Results.

This fulfills the balance storage requirements, reducing costs, not relying on external data availabilty and ensuring the correctness of data. It must be noted, that this also causes the smart-contract to be the single source of 'truth'. Since all balances changes are committed by a new event being emitted and the root being updated, any balance updates must be done through the smart-contract.

\subsubsection{Deposits and Withdraws}
When using the system, a user first has to deposit funds. Since the entire idea of zk-rollup is to move funds to layer-2, the deposit function can be seen as a bridge that connects the mainnet and layer-2. When a user makes a deposit, the funds are represented as a balance object in layer-2, which in turn give custody to these funds. When moving funds in layer-2, we don't actually move the funds residing in the smart-contract, but update the balance objects to represent the movement and verify that movement for correctness with a zkSNARK proof\todo{Maybe remove this?}. Since a balance object gives a user custody of represented funds, it can always be redeemed, moving from layer-2 back to mainnet.  

As described in S. \ref{balances} balance updates are secured by merkle inclusion proofs in the smart-contract. When depositing the user needs to provide a valid merkle path to its balance object, and the balance object itself. The balance object consists of four fields that are needed to represent the balance: ethAmount, tokenAmount, nonce and userAddress. As a first step, the balance object is hashed with the sha256 algorithm, the result being the leaf in the merkle tree. The leaf is now hashed with the merkle path, according to the standart merkle root hashing algorithm. If the resulting hash equals the stored balance root in the contract, we have proven, that the passed balance object is correct. We now add the value of the transaction object, which is the deposit amount sent with the transaction, to the ethAmount, increment the nonce and hash the new balance. Since the balance object has the same position in the tree, the same merkle path is also valid for the new balance. The new leaf is hashed with the merkle path, and the resulting hash is set as the new balance root. As a last step we emit the `BalanceUpdate' event, containing the new balance object, matching the balances with the newly set root. 

Withdraws largely follow the same logic, there are small differences though. As we're requesting funds, instead of sending them, we pass a withdrawAmount as an additional parameter to the function call. We then check if the withdrawAmount <= ethAmount to make sure the withdraw is covered by the users balance. The inclusion proofs are the same, we then subtract the withdrawAmount from the balance, and update the balance root. As a last step we emit the `BalanceUpdate' event with the new balance object, and send requested funds to the user as an on-chain transaction.

This however, is an incomplete explaination, as we're not checking if a user is permitted to deposit or withdraw funds. As balance objects are emitted as an event, anyone can access them and compute valid merkle paths for any balance. This would allow any user to withdraw any balance. To ensure a user is permitted to update a balance object, we need ensure the user controlls the private key belonging to the balance objects user address. Fortunetly we can ensure this by accessing the sender in transaction object. The Ethereum blockchain ensures a user is allowed to make a transaction by requiering the transaction to be signed with the private key of the senders address. If that signature is valid, it is proven that the user has access to the addresses private key and the transaction can be executed. Because of this, the transactions object sender can be trusted to be in controll of the corresponding private key. Instead of passing the users address as part of the balance object, the smart-contract uses the sender of the transaction object. This suffices as a security check.

It must also be noted, that ERC-20 deposits and withdraws behave a bit differently. As every ERC-20 token has its own smart-contract, representing a users balance as a mapping, we need to transfer the assets in that contract. This requires different functions to handle ERC-20 deposits and withdraws, however implementing this is trivial and not worth explaining in the context of this work. 

\begin{figure}[h]
    \centerline{\includegraphics[totalheight=8cm]{diagrams/deposit.png}}
    \caption{Pseudocode of the deposit and withdraw steps}
    \label{fig:dep_with}
\end{figure}


\subsubsection{Batch Verification of Trades}
When trading on Uniswap, every user send a seperate trade transaction, and each trade results in an on-chain movement of funds. This uses quite a lot of gas. zkSwap aims to change this, by aggregating a number of trades into one, executing it and sending the traded funds to th zkSwap contract. The balances of all involved users are then updated accordinly, giving custody to these funds. Since the aggregation happens off-chain, we need to verify its correctness by utilizing a zkSNARK proof. The content of the zkSNARK program, and performed checks and computations will be described in S. XX, we will now focus on the verification step on-chain. 

The zkSwap contract has access to the ZoKrates verifier, which is used for checking if a submitted proof is valid. A valid proof implies, that inputs of the proof have been computed by using the zkSNARK program used for generating the verifier, and with the public inputs defined.  


At its core, a trade on Uniswap is only a update to a users balance. Certain assets are subtracted, other added to the account. The main difference to zkSwap is that traded assets are moves as an on-chain transaction, which uses a large amount of gas. At the same time, every users wishing to trade will do so in a seperate transaction. 


When trading on Uniswap, a user exchanges funds, swapping one for the other. This happens as an on-chain transacation and uses quite a lot of gas. When trading with zkSwap, the balance of a user changes representing the trade in layer-2. However, we want to


At the same time, the funds residing in the smart contract must be able to cover the withdrawl of all balances at all times. 



a users funds is changed in layer-2, representing the funds swapped. A user always has the option to withdraw these, but is free to leave them in layer-2. 

\subsection{Aggregator Entity}
As the name implies, the aggregtor is tasked aggregating the incoming trades. In order to function, a couple of services are needed, with run as smart-contracts on-chain or on a classical server. 

We will now explain each service.

\subsubsection{Merkle Tree}
The first thing to look at is the merkle tree, the aggregator is running. As previously discussed, all balance updates will be committed by the zkSwap smart-contract by emitting the `BalanceUpdate' event. By subscribing to these events, the merkle tree can be built and kept in sync, always providing the complete merkle tree belonging to the balance root stored in the contract. When a `BalanceUpdate' event is received, the balance object is extracted, the corresponding leaf is found in the tree and then replaced with the new data. Rehashing the tree should now result in the balance root set in the contract. The state of the merkle tree can only change by incoming `BalanceUpdate' events.

\subsubsection{Aggregation Server}
It is important to remember, that trade orders are completly off-chain and are sent as an HTTP request. The orders are received and processed by the aggregation server, which at a later stage will run the aggregation. A number of checks are performed on the aggragtion server when a trade is received. These checks are techniqually not needed to ensure the correctness of the aggregation, as the ZoKrates programm performs the same checks at a later stage. They are however needed, to prevent the server from processing invalid trades, which would cause the ZoKrates program to exit in an error state, preventing the entire aggrgation. A trade is invalid, if it fails any of the checks described in this section.

Since this operation is running off-chain, we first need to verify the user is authorized to make the trade order. This can be achived by requesting a signature from the user, verifying it is in controll of the addresses private key. However, it must be remembered, that this signature must also be verifiable in our ZoKrates programm, which is unable to utilize the secp256k1 curve, used for signing Ethereum transaction, efficiently \cite{deml_2019}. For that reason the BN128 curve is used in combination with the EdDSA signature scheme, which can be more efficiently run in a ZoKrates program. The user signs the current balance root, ensuring two things. It proves that the user has access to the addresses private key, which authorizes the trade order. By signing the balance root, we make sure, that the signature can't by reused in a replay attack. For instance, the aggregator could decide to store these signatures secretly, and reuse them without the users consent if this was omitted. 

When the trade order is received, the aggregator first checks if the signature is valid and contains the current balances root, by querying it from the zkSync smart contract. As a next step, it is ensured, the users balance is able to cover the trade. The aggregator queries the merkle tree for the users balance, and checks if the trade can be covered by deposited funds. A last thing to consider is ensuring the correct price of a trade. The price between two assets is constantly changing. At the same time, we're collecting trades in order to aggregate them. This results in a delay between an user sending a trade order and the actual trade execution, during which the price can change drastically. For this reason the zkSwap smart-contact stores a `worst-case' price for buy and sell orders, which is used to calculate the trade order. The worst-case price is used to invalidate an order at a later stage, if the price of an asset pair has crossed it. At this stage, it is ensured that the trade orders price matches the worst-case price stored in the zkSwap smart-contract. If all of these checks pass, the order is added to the trade pool, where it resides until the aggregation starts.  

\begin{figure}[h]
    \centerline{\includegraphics[totalheight=3cm]{diagrams/addTrade.png}}
    \caption{Pseudocode of addTrade()}
    \label{fig:addTrade}
\end{figure}

At some point the trade aggregation is started. This could be triggered by a set blocknumber, the number of trade orders that have been received or any other useful condition defined by the aggregator. When aggregation is started, the first step is to calculate the `net trade'. Since our system aggregates buy and sell orders, we can first offset those internally. By doing this, we're able to reduce the entire aggragation to one Uniswap trade, which saves gas. At the same time, we're saving on the 0.3\% liquidity provider fee, which is charged based on a trades volume. The net trade is the result of off-setting all trades in aggregation, which results one side to equal zero. This trade is now sent as an on-chain transaction to the `PairProxy` contract. 

\subsubsection{PairProxy Smart Contract} \label{pairProxy}
Before explaining the functionalities of this smart-contract, it is important to understand why it is required for the system to function. There are two reasons, a quirk in the way Ethereum handles return values, and the result of dealing with changing price data.
When performing a trade on Uniswap, a user is asked to define a slippage\footnote{Slippage is the difference of the expected and executed price of a trade} for the trade. Since network congestion and the current gas price influence when a transaction is executed, it's a neccecary mechansism for ensuring users can set a `worst-case' price. For this reason, when sending a transaction to the Uniswap trade function, the minAmountReceived parameter must be passed, which we provide by using our `worst-case` price, explained in a previous section. When calling the trade function, the actual amount received is returned as the functions return value. Since this amount might be larger then the amount passed as minAmountReceived, we need it to calculate the post-trade balances. 

However, a quirk in Ethereums way of handling return values makes this more difficult. A smart-contracts functions return value can only be accessed, when called by another smart-contract function. If calling a function as a normal transaction, as the aggregator does, instead of receiving the return value of the function, we receive the transaction recipe, which doesn't contain the return value. For this reason, we need the PairProxy smart-contract, which receives transanactions, forwards them to the respective smart-contract, emitting the return value as an event, which can be consumed by the transactor. 

The PairProxy smart-contract is used for forwarding transactions to the Uniswap or the zkSwap contracts. After the aggregator has calculated the `net trade', it calls the trade function in the PairProxy contract, passing the calculated trade parameters. The PairProxy contract now calls Uniswaps trade function, receiving funds and the amount as a return value. As it has access to the return value, it emits the `TradeComplete' event, containing the amount received in the trade. As it would be inefficient to send the funds back to the aggregator, they reside in the smart-contract. Since the aggregator is set as the owner of the contract, the funds are stored securly.

When verifying the aggregated trades in the zkSwap smart-contract, the transactions is forwarded by the PairProxy again. Since the funds previously traded still reside in the smart-contract, they are attached to the transaction when forwarded to the zkSwap smart-contract.





% This poses a problem, what use is a cheap data storage, if it can be queried from a client 


% The different functions that can be used to update balances will be described at a later point, 

% To achive this, we store balances in a merkle tree in layer-2, each balance stored as a seperate leaf. Merkle trees are a suitable data structure, as the root represents the entire tree state in a highly compressed form, while proving a leafs inclusion in the tree can be done with O(log n). This is ideal for our use-case. We can cheaply commit the merkle trees state to our smart-contract by storing the root, while verifying inclusion of a leaf is very efficient. The different functions that are can be used to update balances will be discussed at a later point, it is important to understand the core technique used for storing balances beforehand.
% The zkSync smart-contract is the only entity in the system that is able to update balances. Since we don't want to rely on external data availability, we need to store state on-chain, but as cheaply as possible. We can do this by emitting an event, thereby writing data to the event log. While the event log can't be accessed from a smart-contracts runtime, it is significantly cheaper then storing data in a smart-contracts storage. 
% a client can query the event log and pass the data as a parameter


% To deposit funds, a user need to provide a valid merkle path to its current balance and the current balance object. The user calls the deposit function, passing the merkle path and balance object as a parameter and adds the funds wishing to be deposited to the transaction. 

% First we check if the balance is included in the tree. To do this, we first hash the balance object with the sha256 algorithm. The balance object contains the following fields: ethBalance, tokenBalance, nonce and address. When hashing the balance object, we extract the users address from the transaction. This ensures that the user is in control of the addresses private key which suffices as security check. Since the contract stores the merkle root, we can now hash the path and balance, checking if we can recreate the root. If the roots match, the trader is permitted to update its balance in the tree. We now update the balance object by adding the deposited amount to the corresponding field, increment the nonce, hash the updated balance object, and rehash the entire tree with the the new balance object. The resulting merkle root is set in the contract, which commits the updated state. 

% However, we still need to store the balances somewhere. As we don't want to rely on external data availability, while keeping storage costs as low as possible, we emit the new balance as an event. Writing data to the event log is a lot cheaper, compared to storage as a variable in a smart-contract. While the event log can't be accessed from a smart-contracts runtime, a client can query the event log and pass the data as a parameter. As the merkle trees state is committed in the contract with the merkle root, correctness can always be proven. 

% Withdrawing funds follows the same logic as deposits. Instead adding funds to the withdraw function, the user passes the amount to withdraw as a parameter. The merkle tree is rehashed, checking if the root is correct, it is ensured the withdrawAmount <= balance, the balance and nonce are updated, creating the new root. We emit the new balance and send the funds to the user. 

% Deposits and withdraws are complete on-chain operations by design. All data needed to withdraw funds are public, except for the private key. This ensures funds can always be withdrawn, as long as the user controlls its private key.

% A trader can deposit funds, by providing a valid merkle path to its current balance as parameters to the zkSwap contract. 




% A trader looking to use the system first needs to deposit funds into the zkSync smart-contract.


% If successful, the deposited amount will be represented as a balance in layer-2. In layer-2, balance objects are stored in a merkle tree, while the root of that tree resides in the zkSync smart-contract. 

% and the amount represented as a balance in layer-2. 

% Since the goal is to store them in layer-2, while remaining free of any external data availability, a somewhat hybrid approach is needed. A trader always must be able to withdraw balance, no matter how many entities are offline. 

\end{document}