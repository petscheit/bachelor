import "hashes/sha256/512bitPadded" as sha256
import "hashes/sha256/1024bitPadded" as sha256_4
import "utils/casts/u32_to_field" as to_field
import "utils/pack/u32/nonStrictUnpack256" as to_u32_8

struct Trade {
        field ethAmount 
        field tokenAmount 
        field nonce
        field deltaEth
        field deltaToken
        field direction // 0: -eth, +token  1: -token, +eth
}

struct Balance {
        field ethAmount
        field tokenAmount
        field nonce
}

def hashPair(u32[8] a, u32[8] b) -> (u32[8]):
	return if to_field(a[0]) <= to_field(b[0]) then sha256(a, b) else sha256(b, a) fi


def hashLeaves(Trade[3] trades) -> (u32[3][8]):
	u32[3][8] res = [[0x00000000;8];3]
	u32[8] padding = [0x00000000;8]
	for field i in 0..3 do
		u32[8] temp = sha256_4(to_u32_8(trades[i].ethAmount), to_u32_8(trades[i].tokenAmount), to_u32_8(trades[i].nonce), padding)
		res[i] = temp
	endfor
	return res

def getPosition(bool proofFlag, field leafPos, field leafsLen) -> (field):
	return if proofFlag then if leafPos < leafsLen then 0 else 1 fi else 2 fi
	
def verifyMultiProof(u32[9][8] leafs, u32[9][8] proofs, bool[9] proofFlags) -> (u32[8]):
	// u32[3][8] leafs = [[0x38723a2e, 0x5e8a17aa, 0x7950dc00, 0x8209944e, 0x898f69a7, 0xbd10a23c, 0x839d341e, 0x935fd5ca],[0xcefc89ad, 0x027150e8, 0x321d90ed, 0xedc04f28, 0xc9122ec8, 0x0d985a2c, 0x48c23941, 0x4f051a46],[0x38723a2e, 0x5e8a17aa, 0x7950dc00, 0x8209944e, 0x898f69a7, 0xbd10a23c, 0x839d341e, 0x935fd5ca]]
	// u32[14][8] proofs = [[0x38723a2e, 0x5e8a17aa, 0x7950dc00, 0x8209944e, 0x898f69a7, 0xbd10a23c, 0x839d341e, 0x935fd5ca],[0x477076ae, 0xafdb714b, 0x192777b7, 0x70ecb909, 0xea1a7fa9, 0xdb8dc3b5, 0x944eb392, 0xf23b6753],[0x96210185, 0xc14a51d9, 0xe128282b, 0xcae13d53, 0xbf1fd6db, 0x271c61ba, 0x2f55097f, 0x58ddc810],[0x61c2de2f, 0xbb276034, 0xf5d1eeb6, 0x1bf1ea40, 0x2265a19f, 0x666c1d1a, 0x723da1fd, 0xc61d0558],[0xed87d3b7, 0x63f55601, 0x8550be2b, 0xa92fa8a8, 0x7a43779f, 0x1b3ed7de, 0x7a4ba3d7, 0x0f1d8c8a],[0xa4bda860, 0xe599d115, 0x4e42ef9f, 0x191996aa, 0xd401752c, 0x26e89853, 0x3c43d625, 0x2da4b967],[0x16b6d44f, 0xceb9d925, 0xac4d1ba5, 0xae90d9a2, 0x50a5c7e1, 0xaf71501a, 0x31351408, 0x7fda6b19],[0x9888c069, 0xc7dec571, 0x3aa8bc43, 0x5c9c6c02, 0xb909c7e1, 0x7201989b, 0x68a5a5fa, 0xdb71aa8b],[0xc24fec06, 0xa2d31f4f, 0xd6dd98c9, 0xc6101ec6, 0x0b2ad1de, 0xd6fa86bd, 0x3329bdb9, 0xe3fc759b],[0x0a1da66c, 0xc836bf27, 0xde970709, 0x0b77ddcc, 0x6cc6556a, 0x23e8ab8c, 0x1fbb9034, 0xd7fed6d7],[0xcc97793b, 0xcf531cb3, 0xbafc7dc7, 0x1322eebd, 0xab7fd1d6, 0x72aa8732, 0xd3455bf2, 0x56729465],[0xa0ae16d3, 0x9114432c, 0xc528c6e3, 0x75ca23b4, 0x1754c9bb, 0xfe13d9b4, 0x7f494fc0, 0xecf210a6],[0x16763a56, 0x68ba0023, 0xb4ce58a5, 0xd7e69c0d, 0xa844ee71, 0xa77a01e5, 0xf947bc14, 0xd133b626],[0xd6dfe2a9, 0xfff51610, 0x0e988dd2, 0x1f690618, 0xd3a51a8b, 0x5da9c59f, 0x39a58567, 0x8201eca8]]
	// bool[16] proofFlags = [true,false,true,false,false,false,false,false,false,false,false,false,false,false,false,false]
	// u32[3][8] leafs = [[0xde47c9b2, 0x7eb8d300, 0xdbb5f2c3, 0x53e632c3, 0x93262cf0, 0x6340c4fa, 0x7f1b40c4, 0xcbd36f90],[0xde47c9b2, 0x7eb8d300, 0xdbb5f2c3, 0x53e632c3, 0x93262cf0, 0x6340c4fa, 0x7f1b40c4, 0xcbd36f90],[0x00000000;8]]
	// u32[3][8] proofs = [[0xde47c9b2, 0x7eb8d300, 0xdbb5f2c3, 0x53e632c3, 0x93262cf0, 0x6340c4fa, 0x7f1b40c4, 0xcbd36f90], [0x41a5cdef, 0xd306be6d, 0x82a6d9dc, 0xfb552c58, 0x4cd96f57, 0xd420a45d, 0xf551d964, 0xa1a0e928],[0x00000000;8]]
	// bool[3] proofFlags = [ false, false, true ]
	// VERY IMPORTANT: leafs.length == proofs.length == proofFlags.length -> Apply padding before submitting

	field leafsLen = 3
	field totalHashes = 9
	u32[9][8] hashes = [[0x00000000;8];9]
	field[3] indexes = [0, 0, 0] // 0: leafPos, 1: hashPos, 2: proofPos
	for field i in 0..totalHashes do
		u32[3][8] nodes = [leafs[indexes[0]], hashes[indexes[1]], proofs[indexes[2]]]
		field aPos = getPosition(proofFlags[i], indexes[0], leafsLen)
		u32[8] a = nodes[aPos]
		indexes[aPos] = indexes[aPos] + 1

		nodes = [leafs[indexes[0]], hashes[indexes[1]], proofs[indexes[2]]]
		field bPos = getPosition(true, indexes[0], leafsLen)
		u32[8] b = nodes[bPos]
		indexes[bPos] = indexes[bPos] + 1
		u32[8] hash = hashPair(a, b)
		hashes[i] = hash
	endfor
	return hashes[totalHashes - 1]

	
def main(Trade[3] trades, private u32[9][8] proof, private bool[9] proofFlags) -> (u32[8]):
	u32[9][8] leafsPadded = [...hashLeaves(trades), ...[[0x00000000;8];6]]

	return verifyMultiProof(leafsPadded, proof, proofFlags)
