import "hashes/sha256/embed/512bitPadded" as sha256
import "hashes/sha256/embed/1024bitPadded" as sha256_4
import "utils/pack/bool/nonStrictUnpack256.zok" as field_to_bool
import "utils/casts/u32_8_to_bool_256.zok" as u32_8_to_bool_256


import "utils/casts/u32_to_field" as to_field
import "utils/pack/u32/nonStrictUnpack256" as to_u32_8
import "utils/casts/bool_256_to_u32_8.zok" as bool_to_u32_8
import "utils/pack/bool/pack128.zok" as pack128
import "utils/pack/bool/unpack128.zok" as unpack128

import "EMBED/unpack" as unpack

struct Balance {
	field ethAmount
	field tokenAmount
	field nonce
	u32[5] address
}

def field_to_64bit(field i) -> bool[64]:
    bool[254] b = unpack(i)
    assert(b[0..190] == [false; 190])
    return b[190..254]

def verifyTrades(Balance[3] oldBalances, Balance[3] newBalances, field ethAmount, field tokenAmount) -> (field, field, field):
	field boughtEth = 0
	field soldEth = 0
	field boughtToken = 0
	field soldToken = 0
	for field i in 0..3 do
		assert(oldBalances[i].nonce == newBalances[i].nonce - 1) // makes sure the nonce is incremented
		field tradeDirection = if oldBalances[i].ethAmount >= newBalances[i].ethAmount then 0 else 1 fi
		field ethDelta = if tradeDirection == 0 then oldBalances[i].ethAmount - newBalances[i].ethAmount else newBalances[i].ethAmount - oldBalances[i].ethAmount fi
		field tokenDelta = if tradeDirection == 0 then newBalances[i].tokenAmount - oldBalances[i].tokenAmount else oldBalances[i].tokenAmount - newBalances[i].tokenAmount fi
		boughtEth = if tradeDirection == 1 then boughtEth + ethDelta else boughtEth fi
		soldEth = if tradeDirection == 0 then soldEth + ethDelta else soldEth fi
		boughtToken = if tradeDirection == 0 then boughtToken + tokenDelta else boughtToken fi
		soldToken = if tradeDirection == 1 then soldToken + tokenDelta else soldToken fi
		// assert(tokenDelta * ethAmount >= ethDelta * tokenAmount && tradeDirection == 0 || tokenDelta * ethAmount <= ethDelta * tokenAmount && tradeDirection == 1) // this works with 64 bit numbers, anything higher will overflow. Maybe check this somewhere?
		assert(tokenDelta * ethAmount >= ethDelta * tokenAmount && tradeDirection == 0 || tradeDirection == 1)
	endfor
	//                                    +Eth, -Token | -Eth, +Token
	field direction = if boughtEth > soldEth then 1 else 0 fi
	field deltaEth = if direction == 1 then boughtEth - soldEth else soldEth - boughtEth fi
	field deltaToken = if direction == 0 then boughtToken - soldToken else soldToken - boughtToken fi
	return direction, deltaEth, deltaToken

def hashPair(bool[256] a, bool[256] b) -> (bool[256]):
	return if pack128(a[0..128]) <= pack128(b[0..128]) then sha256(a, b) else sha256(b, a) fi

def hashLeafs(Balance[3] balances) -> (bool[3][256]):
	bool[3][256] res = [[false;256];3]
	for field i in 0..3 do
		bool[256] addrs = u32_8_to_bool_256([...balances[i].address, 0x00000000, 0x00000000, 0x00000000])
		bool[256] amounts = [...field_to_64bit(balances[i].ethAmount), ...field_to_64bit(balances[i].tokenAmount), ...field_to_64bit(balances[i].nonce), ...field_to_64bit(0)]
		bool[256] temp = sha256(addrs, amounts)
		res[i] = temp
	endfor
	return res

def getPosition(bool proofFlag, field leafPos, field leafsLen) -> (field):
	return if proofFlag then if leafPos < leafsLen then 0 else 1 fi else 2 fi
	
def verifyMultiProof(bool[9][256] leafs, bool[9][256] proofs, bool[9] proofFlags) -> (bool[256]):
	field leafsLen = 3
	field totalHashes = 9
	bool[9][256] hashes = [[false;256];9]
	field[3] indexes = [0, 0, 0] // 0: leafPos, 1: hashPos, 2: proofPos
	for field i in 0..totalHashes do
		bool[3][256] nodes = [leafs[indexes[0]], hashes[indexes[1]], proofs[indexes[2]]]
		field aPos = getPosition(proofFlags[i], indexes[0], leafsLen)
		bool[256] a = nodes[aPos]
		indexes[aPos] = indexes[aPos] + 1

		nodes = [leafs[indexes[0]], hashes[indexes[1]], proofs[indexes[2]]]
		field bPos = getPosition(true, indexes[0], leafsLen)
		bool[256] b = nodes[bPos]
		indexes[bPos] = indexes[bPos] + 1
		bool[256] hash = hashPair(a, b)
		hashes[i] = hash
	endfor
	return hashes[totalHashes - 1]

def hashFinalBalances(bool[3][256] newBalancesHash, field setEthAmount, field setTokenAmount, field deltaEth, field deltaToken, field direction, bool[256] oldRoot, bool[256] newRoot) -> (field[2]): //194615 const
	bool[256] rootPrice = sha256_4(oldRoot, newRoot, [...field_to_64bit(setEthAmount), ...field_to_64bit(setTokenAmount), ...field_to_64bit(deltaEth), ...field_to_64bit(deltaToken)], field_to_bool(direction))
	bool[256] res = sha256_4(newBalancesHash[0], newBalancesHash[1], newBalancesHash[2], rootPrice) // hacky
	return [pack128(res[0..128]), pack128(res[128..256])]

def proofToBin(field[9][2] proof) -> (bool[9][256]): //587502
	bool[9][256] result = [[false;256];9]
	for field i in 0..9 do
		result[i] = [...unpack128(proof[i][0]), ...unpack128(proof[i][1])]
	endfor
	return result

def main(private Balance[3] oldBalances, private Balance[3] newBalances, private field[9][2] proof, private bool[9] proofFlags, private field[2] root, private field setEthAmount, private field setTokenAmount) -> (field[2]):
	field direction, field deltaEth, field deltaToken = verifyTrades(oldBalances, newBalances, setEthAmount, setTokenAmount)
	bool[9][256] leafsPadded = [...hashLeafs(oldBalances), ...[[false;256];6]] // we need to pass empty leafs for this to compile. The proof flags will ensure that these values are never used for hashing
	bool[9][256] proofBin = proofToBin(proof)
	bool[256] calcedRoot = verifyMultiProof(leafsPadded, proofBin, proofFlags)
	field[2] calcedRootField = [pack128(calcedRoot[0..128]), pack128(calcedRoot[128..256])]
	assert(root[0] == calcedRootField[0] && root[1] == calcedRootField[1]) // passed trades contain correct balances. First check OK
	bool[9][256] newLeafsPadded = [...hashLeafs(newBalances), ...[[false;256];6]]
	bool[256] newRoot = verifyMultiProof(newLeafsPadded, proofBin, proofFlags)
	return hashFinalBalances(newLeafsPadded[0..3], setEthAmount, setTokenAmount, deltaEth, deltaToken, direction, calcedRoot, newRoot)


// TODO:
// - Signature check
// contain error in 2nd trade
// Balance[3] oldBalances = [Balance{ethAmount:10000000000,tokenAmount:0,nonce:1,address:[0xcc08e563,0x6A9ceb03,0x917C1ac7,0xBbEda23a,0xD57766F3]},Balance{ethAmount:0,tokenAmount:50000000000000,nonce:1,address:[0x31b87891,0x8679d9DA,0x1DB277B1,0xA2fD67Aa,0x01032920]},Balance{ethAmount:25010000000,tokenAmount:0,nonce:2,address:[0x1D539b71,0x7035B802,0x40d6e783,0x6B2C752E,0x204B7DD4]}]
// Balance[3] newBalances = [Balance{ethAmount:0,tokenAmount:18030043450000,nonce:2,address:[0xcc08e563,0x6A9ceb03,0x917C1ac7,0xBbEda23a,0xD57766F3]},Balance{ethAmount:27731491684,tokenAmount:0,nonce:2,address:[0x31b87891,0x8679d9DA,0x1DB277B1,0xA2fD67Aa,0x01032920]},Balance{ethAmount:10000000,tokenAmount:45075108625000,nonce:3,address:[0x1D539b71,0x7035B802,0x40d6e783,0x6B2C752E,0x204B7DD4]}]
// field[9][2] proof = [[326522724692461750427768532537390503835,89059515727727869117346995944635890507],[265181187819933133817279458938021520211,226826845712117313199728648141007401788],[110894977352237344843883812633147901333,90983754514093244277048472558931415612],[211336224248324717186270758123443705798,103214039003913815936073814883481423152],[287849902845851149564392658358832810366,22992467719797921752054319444564123553],[180666250266229371542610003800057229145,156693885583226463728325172930408513324],[51198084693452429383185080494257164612,322193689052356961661042599016221487507],[0,0],[0,0]]
// bool[9] proofFlags = [true,false,true,false,false,false,false,false,false]
// field[2] root = [335316615939267250285026572727597754018,304430889608956088306359871272981840661]
// field setEthAmount = 1000000000000
// field setTokenAmount = 1803004345000000