import "hashes/sha256/512bitPadded" as sha256
import "hashes/sha256/1024bitPadded" as sha256_4
import "utils/casts/u32_to_field" as to_field
import "utils/pack/u32/nonStrictUnpack256" as to_u32_8

struct Trade {
	field ethAmount 
	field tokenAmount 
	field nonce
	field deltaEth
	field deltaToken
	field direction // 0: -eth, +token  1: -token, +eth
	u32[5] address
}

struct Balance {
	field ethAmount
	field tokenAmount
	field nonce
	u32[5] address
}

def checkEthSell(Trade trade) -> Balance: 
	bool valid = trade.ethAmount >= trade.deltaEth      
	Balance res = if valid \
			then Balance { ethAmount: trade.ethAmount - trade.deltaEth, tokenAmount: trade.tokenAmount + trade.deltaToken, nonce: trade.nonce + 1, address: trade.address } \
			else Balance { ethAmount: trade.ethAmount, tokenAmount: trade.tokenAmount, nonce: trade.nonce, address: trade.address } fi
	return res

def checkTokenSell(Trade trade) -> Balance:
	bool valid = trade.tokenAmount >= trade.deltaToken
	Balance res = if valid \
			then Balance { ethAmount: trade.ethAmount + trade.deltaEth, tokenAmount: trade.tokenAmount - trade.deltaToken, nonce: trade.nonce + 1, address: trade.address } \
			else Balance { ethAmount: trade.ethAmount, tokenAmount: trade.tokenAmount, nonce: trade.nonce, address: trade.address } fi
	return res

def hashPair(u32[8] a, u32[8] b) -> (u32[8]):
	return if to_field(a[0]) <= to_field(b[0]) then sha256(a, b) else sha256(b, a) fi

def hashLeafs(Trade[3] trades) -> (u32[3][8]):
	u32[3][8] res = [[0x00000000;8];3] // TODO use proper sha2 spec padding
	u32[8] padding = [0x00000000;8]
	for field i in 0..3 do
		u32[8] temp = sha256_4(to_u32_8(trades[i].ethAmount), to_u32_8(trades[i].tokenAmount), to_u32_8(trades[i].nonce), padding)
		res[i] = temp
	endfor
	return res

def hashLeafs(Balance[3] balances) -> (u32[3][8]):
	u32[3][8] res = [[0x00000000;8];3]
	u32[8] padding = [0x00000000;8]
	for field i in 0..3 do
		u32[8] temp = sha256_4(to_u32_8(balances[i].ethAmount), to_u32_8(balances[i].tokenAmount), to_u32_8(balances[i].nonce), padding)
		res[i] = temp
	endfor
	return res

def getPosition(bool proofFlag, field leafPos, field leafsLen) -> (field):
	return if proofFlag then if leafPos < leafsLen then 0 else 1 fi else 2 fi
	
def verifyMultiProof(u32[9][8] leafs, u32[9][8] proofs, bool[9] proofFlags) -> (u32[8]):
	field leafsLen = 3
	field totalHashes = 9
	u32[9][8] hashes = [[0x00000000;8];9]
	field[3] indexes = [0, 0, 0] // 0: leafPos, 1: hashPos, 2: proofPos
	for field i in 0..totalHashes do
		u32[3][8] nodes = [leafs[indexes[0]], hashes[indexes[1]], proofs[indexes[2]]]
		field aPos = getPosition(proofFlags[i], indexes[0], leafsLen)
		u32[8] a = nodes[aPos]
		indexes[aPos] = indexes[aPos] + 1

		nodes = [leafs[indexes[0]], hashes[indexes[1]], proofs[indexes[2]]]
		field bPos = getPosition(true, indexes[0], leafsLen)
		u32[8] b = nodes[bPos]
		indexes[bPos] = indexes[bPos] + 1
		u32[8] hash = hashPair(a, b)
		hashes[i] = hash
	endfor
	return hashes[totalHashes - 1]

def hashFinalBalances(Balance[3] balances) -> (u32[8]):
	u32[8] dummyBlock = [0x80000000, ...[0x00000000;6], 0x00000300]
	u32[3] paddingAddress = [0x80000000, 0x00000000, 0x000003A0]
	return sha256_4( \
		sha256_4(to_u32_8(balances[0].ethAmount), to_u32_8(balances[0].tokenAmount), to_u32_8(balances[0].nonce), [...balances[0].address, ...paddingAddress]), \
		sha256_4(to_u32_8(balances[1].ethAmount), to_u32_8(balances[1].tokenAmount), to_u32_8(balances[1].nonce), [...balances[1].address, ...paddingAddress]), \
		sha256_4(to_u32_8(balances[2].ethAmount), to_u32_8(balances[2].tokenAmount), to_u32_8(balances[2].nonce), [...balances[2].address, ...paddingAddress]), \
		dummyBlock)

def updateBalances(Trade[3] trades) -> (Balance[3]):
	Balance[3] balances = [Balance{ ethAmount: 0, tokenAmount: 0, nonce: 0, address: [0x00000000; 5] };3]
	for field i in 0..3 do
		Balance bal= if trades[i].direction == 0 then checkEthSell(trades[i]) else checkTokenSell(trades[i]) fi
		balances[i] = bal
	endfor
	return balances

def main(private Trade[3] trades, private u32[9][8] proof, private bool[9] proofFlags, u32[8] root) -> (Balance[3], u32[8], u32[8]):
	u32[9][8] leafsPadded = [...hashLeafs(trades), ...[[0x00000000;8];6]] // we need to pass empty leafs for this to compile. The proof flags will ensure that these values are never used for hashing
	assert(root == verifyMultiProof(leafsPadded, proof, proofFlags)) // passed trades contain correct balances. First check OK
	Balance[3] balances = updateBalances(trades)
	u32[9][8] newLeafsPadded = [...hashLeafs(trades), ...[[0x00000000;8];6]]
	u32[8] newRoot = verifyMultiProof(newLeafsPadded, proof, proofFlags)
	return balances, newRoot, hashFinalBalances(balances)
