import "hashes/sha256/512bitPadded" as sha256
import "hashes/sha256/1024bitPadded" as sha256_4
import "utils/casts/u32_to_field" as to_field
import "utils/pack/u32/nonStrictUnpack256" as to_u32_8

struct Balance {
	field ethAmount
	field tokenAmount
	field nonce
	u32[5] address
}

def hashPair(u32[8] a, u32[8] b) -> (u32[8]):
	return if to_field(a[0]) <= to_field(b[0]) then sha256(a, b) else sha256(b, a) fi

def hashLeafs(Balance[3] balances) -> (u32[3][8]): // TODO: use sha-2 spec padding
	u32[3][8] res = [[0x00000000;8];3]
	u32[8] padding = [0x00000000;8]
	for field i in 0..3 do
		u32[8] temp = sha256_4(to_u32_8(balances[i].ethAmount), to_u32_8(balances[i].tokenAmount), to_u32_8(balances[i].nonce), padding)
		res[i] = temp
	endfor
	return res

def getPosition(bool proofFlag, field leafPos, field leafsLen) -> (field):
	return if proofFlag then if leafPos < leafsLen then 0 else 1 fi else 2 fi
	
def verifyMultiProof(u32[9][8] leafs, u32[9][8] proofs, bool[9] proofFlags) -> (u32[8]):
	field leafsLen = 3
	field totalHashes = 9
	u32[9][8] hashes = [[0x00000000;8];9]
	field[3] indexes = [0, 0, 0] // 0: leafPos, 1: hashPos, 2: proofPos
	for field i in 0..totalHashes do
		u32[3][8] nodes = [leafs[indexes[0]], hashes[indexes[1]], proofs[indexes[2]]]
		field aPos = getPosition(proofFlags[i], indexes[0], leafsLen)
		u32[8] a = nodes[aPos]
		indexes[aPos] = indexes[aPos] + 1

		nodes = [leafs[indexes[0]], hashes[indexes[1]], proofs[indexes[2]]]
		field bPos = getPosition(true, indexes[0], leafsLen)
		u32[8] b = nodes[bPos]
		indexes[bPos] = indexes[bPos] + 1
		u32[8] hash = hashPair(a, b)
		hashes[i] = hash
	endfor
	return hashes[totalHashes - 1]

def hashFinalBalances(Balance[3] balances) -> (u32[8]):
	u32[8] dummyBlock = [0x80000000, ...[0x00000000;6], 0x00000300]
	u32[3] paddingAddress = [0x80000000, 0x00000000, 0x000003A0]
	return sha256_4( \
		sha256_4(to_u32_8(balances[0].ethAmount), to_u32_8(balances[0].tokenAmount), to_u32_8(balances[0].nonce), [...balances[0].address, ...paddingAddress]), \
		sha256_4(to_u32_8(balances[1].ethAmount), to_u32_8(balances[1].tokenAmount), to_u32_8(balances[1].nonce), [...balances[1].address, ...paddingAddress]), \
		sha256_4(to_u32_8(balances[2].ethAmount), to_u32_8(balances[2].tokenAmount), to_u32_8(balances[2].nonce), [...balances[2].address, ...paddingAddress]), \
		dummyBlock)

def main(private Balance[3] oldBalances, private Balance[3] newBalances, private u32[9][8] proof, private bool[9] proofFlags, private u32[8] root) -> (u32[8], u32[8]):
	u32[9][8] leafsPadded = [...hashLeafs(oldBalances), ...[[0x00000000;8];6]] // we need to pass empty leafs for this to compile. The proof flags will ensure that these values are never used for hashing
	assert(root == verifyMultiProof(leafsPadded, proof, proofFlags)) // passed trades contain correct balances. First check OK
	u32[9][8] newLeafsPadded = [...hashLeafs(newBalances), ...[[0x00000000;8];6]]
	u32[8] newRoot = verifyMultiProof(newLeafsPadded, proof, proofFlags)
	return newRoot, hashFinalBalances(newBalances)


// TODO:
// - Signatures
// - Nonce check
// - Price check