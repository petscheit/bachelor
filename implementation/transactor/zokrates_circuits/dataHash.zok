import "hashes/sha256/1024bit" as sha256_4
import "utils/pack/u32/nonStrictUnpack256" as to_u32_8

struct Balance {
	field ethAmount
	field tokenAmount
	field nonce
	u32[5] address
}

def main() -> (u32[8]):
	u32[8] dummyBlock = [0x80000000, ...[0x00000000;6], 0x00000300]
	u32[3] paddingAddress = [0x80000000, 0x00000000, 0x000003A0]
	u32[5] address = [0x4d9b01D7, 0x11c90883, 0x3f97ea78, 0xCF2AE0C7, 0x74607a4d]
	Balance[3] balances = [ Balance { ethAmount: 0, tokenAmount: 0, nonce: 0, address: address}, Balance { ethAmount: 0, tokenAmount: 0, nonce: 0, address: address }, Balance { ethAmount: 0, tokenAmount: 0, nonce: 0, address: address }]
	return sha256_4( \
		sha256_4(to_u32_8(balances[0].ethAmount), to_u32_8(balances[0].tokenAmount), to_u32_8(balances[0].nonce), [...address, ...paddingAddress]), \
		sha256_4(to_u32_8(balances[1].ethAmount), to_u32_8(balances[1].tokenAmount), to_u32_8(balances[1].nonce), [...address, ...paddingAddress]), \
		sha256_4(to_u32_8(balances[2].ethAmount), to_u32_8(balances[2].tokenAmount), to_u32_8(balances[2].nonce), [...address, ...paddingAddress]), \
		dummyBlock)
	// return sha256_4(to_u32_8(balances[0].ethAmount), to_u32_8(balances[0].tokenAmount), to_u32_8(balances[0].nonce), [...address, ...paddingAddress])

// def convertAddress