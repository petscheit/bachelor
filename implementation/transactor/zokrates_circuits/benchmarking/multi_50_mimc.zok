import "hashes/sha256/embed/512bitPadded" as sha256
import "hashes/sha256/embed/1024bitPadded" as sha256_4
import "utils/pack/bool/nonStrictUnpack256.zok" as field_to_bool
import "utils/casts/u32_8_to_bool_256.zok" as u32_8_to_bool_256
import "hashes/mimcSponge/mimcFeistel" as MiMCFeistel
import "utils/pack/bool/pack128.zok" as pack128
import "utils/pack/bool/pack256.zok" as pack256
import "utils/pack/bool/unpack128.zok" as unpack128
import "EMBED/unpack" as unpack

struct Balance {
	field ethAmount
	field tokenAmount
	field nonce
	u32[5] address
}

def mimc_4(field[4] ins) -> field: //5281
	field nInputs = 4
	field nOutputs = 1
	field[4][2] S = [[0; 2]; 4] // Dim: (nInputs + nOutputs - 1, 2)
	field outs = 0

	for field i in 0..nInputs do
		field idx = if i == 0 then 0 else i - 1 fi
		S[i] = if i == 0 then MiMCFeistel(ins[0], 0, 0) else MiMCFeistel(S[idx][0] + ins[i], S[idx][1], 0) fi
	endfor
	outs = S[nInputs - 1][0]
	return outs

def field_to_64bit(field i) -> bool[64]:
    bool[254] b = unpack(i)
    assert(b[0..190] == [false; 190])
    return b[190..254]

def verifyTrades(Balance[50] oldBalances, Balance[50] newBalances, field ethToToken, field tokenToEth) -> (field, field, field):
	field boughtEth = 0
	field soldEth = 0
	field boughtToken = 0
	field soldToken = 0
	for field i in 0..50 do
		assert(oldBalances[i].nonce == newBalances[i].nonce - 1) // makes sure the nonce is incremented
		field tradeDirection = if oldBalances[i].ethAmount >= newBalances[i].ethAmount then 0 else 1 fi
		field deltaEth = if tradeDirection == 0 then oldBalances[i].ethAmount - newBalances[i].ethAmount else newBalances[i].ethAmount - oldBalances[i].ethAmount fi
		field deltaToken = if tradeDirection == 0 then newBalances[i].tokenAmount - oldBalances[i].tokenAmount else oldBalances[i].tokenAmount - newBalances[i].tokenAmount fi
		boughtEth = if tradeDirection == 1 then boughtEth + deltaEth else boughtEth fi
		soldEth = if tradeDirection == 0 then soldEth + deltaEth else soldEth fi
		boughtToken = if tradeDirection == 0 then boughtToken + deltaToken else boughtToken fi
		soldToken = if tradeDirection == 1 then soldToken + deltaToken else soldToken fi
		assert(ethToToken * deltaEth == 10000000000 * deltaToken && tradeDirection == 0 || 1000000000000 * deltaEth == tokenToEth * deltaToken && tradeDirection == 1)
	endfor
	//                                    +Eth, -Token | -Eth, +Token
	field direction = if boughtEth > soldEth then 1 else 0 fi
	field deltaEth = if direction == 1 then boughtEth - soldEth else soldEth - boughtEth fi
	field deltaToken = if direction == 0 then boughtToken - soldToken else soldToken - boughtToken fi
	return direction, deltaEth, deltaToken

def mimc(field[2] ins) -> field:
	field nInputs = 2
	field nOutputs = 1
	field[2][2] S = [[0; 2]; 2] // Dim: (nInputs + nOutputs - 1, 2)

	for field i in 0..nInputs do
		field idx = if i == 0 then 0 else i - 1 fi
		S[i] = if i == 0 then MiMCFeistel(ins[0], 0, 0) else MiMCFeistel(S[idx][0] + ins[i], S[idx][1], 0) fi
	endfor
	return S[nInputs - 1][0]

def mimcHashPair(field a, field b) -> (field):
	return if a > b then mimc([a, b]) else mimc([b, a]) fi

def hashLeafs(Balance[50] balances) -> (field[50]):
	field[50] res = [0;50]
	for field i in 0..50 do
		field addrs = pack256(u32_8_to_bool_256([...balances[i].address, 0x00000000, 0x00000000, 0x00000000]))
		field temp = mimc_4([addrs, balances[i].ethAmount, balances[i].tokenAmount, balances[i].nonce])
		res[i] = temp
	endfor
	return res

def getPosition(bool proofFlag, field leafPos, field leafsLen) -> (field):
	return if proofFlag then if leafPos < leafsLen then 0 else 1 fi else 2 fi
	
def verifyMultiProof(field[383] leafs, field[334] proofs, bool[383] proofFlags) -> (field): //92806
	field leafsLen = 50
	field totalHashes = 383
	field[383] hashes = [0;383]
	field[3] indexes = [0, 0, 0] // 0: leafPos, 1: hashPos, 2: proofPos
	for field i in 0..totalHashes do
		field[3] nodes = [leafs[indexes[0]], hashes[indexes[1]], proofs[indexes[2]]]
		field aPos = getPosition(proofFlags[i], indexes[0], leafsLen)
		field a = nodes[aPos]
		indexes[aPos] = indexes[aPos] + 1

		nodes = [leafs[indexes[0]], hashes[indexes[1]], proofs[indexes[2]]]
		field bPos = getPosition(true, indexes[0], leafsLen)
		field b = nodes[bPos]
		indexes[bPos] = indexes[bPos] + 1
		field hash = mimcHashPair(a, b)
		hashes[i] = hash
	endfor
	return hashes[totalHashes - 1]

def hashFinalBalances(field[50] newBalancesHash, field ethToToken, field tokenToEth, field deltaEth, field deltaToken, field direction, field oldRoot, field newRoot) -> (field[2]): //194615 const
	bool[256] rootPrice = sha256_4(field_to_bool(oldRoot), field_to_bool(newRoot), [...field_to_64bit(ethToToken), ...field_to_64bit(tokenToEth), ...field_to_64bit(deltaEth), ...field_to_64bit(deltaToken)], field_to_bool(direction))
	bool[256] res = [false;256]
	for field i in 0..50 do
		res = sha256(res, field_to_bool(newBalancesHash[i]))
	endfor
	bool[256] final = sha256(res, rootPrice) // hacky
	return [pack128(final[0..128]), pack128(final[128..256])]

def main(private Balance[50] oldBalances, private Balance[50] newBalances, private field[334] proof, private bool[383] proofFlags, private field root, private field ethToToken, private field tokenToEth) -> (field[2]):
	field direction, field deltaEth, field deltaToken = verifyTrades(oldBalances, newBalances, ethToToken, tokenToEth)
	field[383] leafsPadded = [...hashLeafs(oldBalances), ...[0;333]] // we need to pass empty leafs for this to compile. The proof flags will ensure that these values are never used for hashing
	field calcedRoot = verifyMultiProof(leafsPadded, proof, proofFlags)
	assert(root == calcedRoot) // passed trades contain correct balances. First check OK
	field[383] newLeafsPadded = [...hashLeafs(newBalances), ...[0;333]]
	field newRoot = verifyMultiProof(newLeafsPadded, proof, proofFlags)
	return hashFinalBalances(newLeafsPadded[0..50], ethToToken, tokenToEth, deltaEth, deltaToken, direction, calcedRoot, newRoot)