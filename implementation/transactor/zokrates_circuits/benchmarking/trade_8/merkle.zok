import "utils/pack/bool/pack256.zok" as pack256
import "utils/casts/u32_8_to_bool_256.zok" as u32_8_to_bool_256
import "hashes/mimcSponge/mimcFeistel" as MiMCFeistel
import "utils/pack/bool/pack128.zok" as pack128

struct BalanceUpdate {
	field oldEthAmount
	field oldTokenAmount
	field oldNonce
	field newEthAmount
	field newTokenAmount
	field newNonce
	u32[5] address
	field[16][2] merklePath
}

def mimc_4(field[4] ins) -> field: //5281
	field nInputs = 4
	field nOutputs = 1
	field[4][2] S = [[0; 2]; 4] // Dim: (nInputs + nOutputs - 1, 2)
	field outs = 0

	for field i in 0..nInputs do
		field idx = if i == 0 then 0 else i - 1 fi
		S[i] = if i == 0 then MiMCFeistel(ins[0], 0, 0) else MiMCFeistel(S[idx][0] + ins[i], S[idx][1], 0) fi
	endfor
	outs = S[nInputs - 1][0]
	return outs

def mimc(field[2] ins) -> field:
	field nInputs = 2
	field nOutputs = 1
	field[2][2] S = [[0; 2]; 2] // Dim: (nInputs + nOutputs - 1, 2)

	for field i in 0..nInputs do
		field idx = if i == 0 then 0 else i - 1 fi
		S[i] = if i == 0 then MiMCFeistel(ins[0], 0, 0) else MiMCFeistel(S[idx][0] + ins[i], S[idx][1], 0) fi
	endfor
	return S[nInputs - 1][0]

def hashLeaf(BalanceUpdate balance) -> (field[2]):
	field[2] res = [0,0]
	field addrs = pack256(u32_8_to_bool_256([...balance.address, 0x00000000, 0x00000000, 0x00000000]))
	field temp = mimc_4([addrs, balance.oldEthAmount, balance.oldTokenAmount, balance.oldNonce])
	res[0] = temp
	temp = mimc_4([addrs, balance.oldEthAmount, balance.oldTokenAmount, balance.oldNonce])
	res[1] = temp
	return res

def computeMerkle(field[16][2] merklePath, field leaf) -> (field):
	field computedHash = leaf
	for field i in 0..16 do
		computedHash = if merklePath[i][1] == 0 then mimc([computedHash, merklePath[i][0]]) else mimc([merklePath[i][0], computedHash]) fi
	endfor
	return computedHash

def verifyLeaf(field[2] hashedLeaf, field[16][2] merklePath, field root) -> (field):
	field calcedRootField = computeMerkle(merklePath, hashedLeaf[0])
	assert(root == root) // old root can be reconstructed
	return computeMerkle(merklePath, hashedLeaf[1])
	
def main(BalanceUpdate[1] balances, field root) -> (field[2]):
	field[2] newBalanceHashed = [0;2]
	for field i in 0..1 do
		field[2] hashedBalance = hashLeaf(balances[i])
		newBalanceHashed[i] = hashedBalance[1]
		root = verifyLeaf(hashedBalance, balances[i].merklePath, root)
	endfor
	newBalanceHashed[1] = root
	return newBalanceHashed


// 0: 1	-> per balance 95254
// 1: 95255
// 2: 190509
// 3: 285763


// Using tree depth of 16:
// 0: 1 -> per balance 179782
// 1: 179783
