// echo "[[{\"oldEthAmount\":\"0\",\"oldTokenAmount\":\"0\",\"oldNonce\":\"0\",\"newEthAmount\":\"1000000000000\",\"newTokenAmount\":\"0\",\"newNonce\":\"1\",\"movementType\":\"0\",\"address\":[\"0x31b87891\",\"0x8679d9DA\",\"0x1DB277B1\",\"0xA2fD67Aa\",\"0x01032920\"],\"merklePath\":[[\"0\",\"1\"],[\"1\",\"0\"],[\"0\",\"1\"],[\"1\",\"0\"],[\"0\",\"1\"],[\"1\",\"0\"],[\"0\",\"1\"],[\"1\",\"0\"]]},{\"oldEthAmount\":\"1000000000000\",\"oldTokenAmount\":\"0\",\"oldNonce\":\"0\",\"newEthAmount\":\"0\",\"newTokenAmount\":\"0\",\"newNonce\":\"1\",\"movementType\":\"1\",\"address\":[\"0x31b87891\",\"0x8679d9DA\",\"0x1DB277B1\",\"0xA2fD67Aa\",\"0x01032920\"],\"merklePath\":[[\"0\",\"1\"],[\"1\",\"0\"],[\"0\",\"1\"],[\"1\",\"0\"],[\"0\",\"1\"],[\"1\",\"0\"],[\"0\",\"1\"],[\"1\",\"0\"]]},{\"oldEthAmount\":\"0\",\"oldTokenAmount\":\"0\",\"oldNonce\":\"0\",\"newEthAmount\":\"1000000000000\",\"newTokenAmount\":\"0\",\"newNonce\":\"1\",\"movementType\":\"0\",\"address\":[\"0x31b87891\",\"0x8679d9DA\",\"0x1DB277B1\",\"0xA2fD67Aa\",\"0x01032920\"],\"merklePath\":[[\"0\",\"1\"],[\"1\",\"0\"],[\"0\",\"1\"],[\"1\",\"0\"],[\"0\",\"1\"],[\"1\",\"0\"],[\"0\",\"1\"],[\"1\",\"0\"]]}],\"1111111\"]" | ./memusg.sh zokrates compute-witness --light --abi --abi_spec ./abi.json --stdin >> console_log.txt
import "hashes/sha256/embed/512bitPadded" as sha256
import "utils/pack/bool/nonStrictUnpack256.zok" as field_to_bool
import "utils/pack/bool/pack128.zok" as pack128
import "hashes/sha256/embed/1024bitPadded" as sha256_4
import "utils/casts/u32_8_to_bool_256.zok" as u32_8_to_bool_256
import "EMBED/unpack" as unpack

struct BalanceMovementObject {
	field oldEthAmount
	field oldTokenAmount
	field oldNonce
	field newEthAmount
	field newTokenAmount
	field newNonce
	u32[5] address
	field[16][2] merklePath
}
def field_to_64bit(field i) -> bool[64]:
    bool[254] b = unpack(i)
    assert(b[0..190] == [false; 190])
    return b[190..254]

def main(BalanceMovementObject[3] balances, field oldRoot, field newRoot) -> (field[2]):
    bool[256] res = sha256(field_to_bool(oldRoot), field_to_bool(newRoot))
    for field i in 0..3 do
        bool[256] addrs = u32_8_to_bool_256([...balances[i].address, 0x00000000, 0x00000000, 0x00000000])
	    bool[256] amounts = [...field_to_64bit(balances[i].newEthAmount), ...field_to_64bit(balances[i].newTokenAmount), ...field_to_64bit(balances[i].newNonce), ...field_to_64bit(0)]
        res = sha256(res, sha256(addrs, amounts))
    endfor
    return [pack128(res[0..128]), pack128(res[128..256])]

// 0: 55970 -> per balance 184806
// 1: 240776
// 2: 425582
// 3: 610388
