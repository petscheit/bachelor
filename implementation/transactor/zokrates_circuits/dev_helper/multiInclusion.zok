import "hashes/sha256/embed/512bitPadded" as sha256
import "hashes/sha256/embed/1024bitPadded" as sha256_4
import "utils/pack/bool/nonStrictUnpack256.zok" as field_to_bool
import "utils/casts/u32_8_to_bool_256.zok" as u32_8_to_bool_256
import "utils/pack/bool/pack256.zok" as pack256
import "hashes/mimcSponge/mimcFeistel" as MiMCFeistel

import "utils/casts/u32_to_field" as to_field
import "utils/pack/u32/nonStrictUnpack256" as to_u32_8
import "utils/casts/bool_256_to_u32_8.zok" as bool_to_u32_8
import "utils/pack/bool/pack128.zok" as pack128
import "utils/pack/bool/unpack128.zok" as unpack128

import "EMBED/unpack" as unpack

def mimc(field[2] ins) -> field:
	field nInputs = 2
	field nOutputs = 1
	field[2][2] S = [[0; 2]; 2] // Dim: (nInputs + nOutputs - 1, 2)
	field outs = 0

	for field i in 0..nInputs do
		field idx = if i == 0 then 0 else i - 1 fi
		S[i] = if i == 0 then MiMCFeistel(ins[0], 0, 0) else MiMCFeistel(S[idx][0] + ins[i], S[idx][1], 0) fi
	endfor
	return S[nInputs - 1][0]

def mimcHashPair(field a, field b) -> (field):
	return if a > b then mimc([a, b]) else mimc([b, a]) fi

def getPosition(bool proofFlag, field leafPos, field leafsLen) -> (field):
	return if proofFlag then if leafPos < leafsLen then 0 else 1 fi else 2 fi

def mainn(field[9] leafs, field[9] proofs, bool[9] proofFlags) -> (field): //92806
	field leafsLen = 3
	field totalHashes = 9
	field[9] hashes = [0;9]
	field[3] indexes = [0, 0, 0] // 0: leafPos, 1: hashPos, 2: proofPos
	for field i in 0..totalHashes do
		field[3] nodes = [leafs[indexes[0]], hashes[indexes[1]], proofs[indexes[2]]]
		field aPos = getPosition(proofFlags[i], indexes[0], leafsLen)
		field a = nodes[aPos]
		indexes[aPos] = indexes[aPos] + 1

		nodes = [leafs[indexes[0]], hashes[indexes[1]], proofs[indexes[2]]]
		field bPos = getPosition(true, indexes[0], leafsLen)
		field b = nodes[bPos]
		indexes[bPos] = indexes[bPos] + 1
		field hash = mimcHashPair(a, b)
		hashes[i] = hash
	endfor
	return hashes[totalHashes - 1]

// ______________________________________________________________________________

def hashPair(bool[256] a, bool[256] b) -> (bool[256]):
	return if pack128(a[0..128]) <= pack128(b[0..128]) then sha256(a, b) else sha256(b, a) fi
	
def main(bool[9][256] leafs, bool[9][256] proofs, bool[9] proofFlags) -> (bool[256]): //2176276
	field leafsLen = 3
	field totalHashes = 9
	bool[9][256] hashes = [[false;256];9]
	field[3] indexes = [0, 0, 0] // 0: leafPos, 1: hashPos, 2: proofPos
	for field i in 0..totalHashes do
		bool[3][256] nodes = [leafs[indexes[0]], hashes[indexes[1]], proofs[indexes[2]]]
		field aPos = getPosition(proofFlags[i], indexes[0], leafsLen)
		bool[256] a = nodes[aPos]
		indexes[aPos] = indexes[aPos] + 1

		nodes = [leafs[indexes[0]], hashes[indexes[1]], proofs[indexes[2]]]
		field bPos = getPosition(true, indexes[0], leafsLen)
		bool[256] b = nodes[bPos]
		indexes[bPos] = indexes[bPos] + 1
		bool[256] hash = hashPair(a, b)
		hashes[i] = hash
	endfor
	return hashes[totalHashes - 1]