import "hashes/sha256/embed/512bitPadded" as sha256
import "hashes/sha256/embed/1024bitPadded" as sha256_4
import "utils/pack/bool/nonStrictUnpack256.zok" as field_to_bool
import "utils/casts/u32_8_to_bool_256.zok" as u32_8_to_bool_256
import "utils/pack/bool/pack256.zok" as pack256
import "hashes/mimcSponge/mimcFeistel" as MiMCFeistel

import "utils/casts/u32_to_field" as to_field
import "utils/pack/u32/nonStrictUnpack256" as to_u32_8
import "utils/casts/bool_256_to_u32_8.zok" as bool_to_u32_8
import "utils/pack/bool/pack128.zok" as pack128
import "utils/pack/bool/unpack128.zok" as unpack128

import "EMBED/unpack" as unpack
struct Balance {
	field ethAmount
	field tokenAmount
	field nonce
	u32[5] address
}
def mimc(field[2] ins, field k) -> field:
	//nInputs = 2, nOutputs = 3,
	field nInputs = 2
	field nOutputs = 1
	field[2][2] S = [[0; 2]; 2] // Dim: (nInputs + nOutputs - 1, 2)
	field outs = 0

	for field i in 0..nInputs do
		field idx = if i == 0 then 0 else i - 1 fi
		S[i] = if i == 0 then MiMCFeistel(ins[0], 0, k) else MiMCFeistel(S[idx][0] + ins[i], S[idx][1], k) fi
	endfor
	outs = S[nInputs - 1][0]

	// for field i in 0..(nOutputs - 1) do
	// 	field[2] feistelRes = MiMCFeistel(S[nInputs + i - 1][0], S[nInputs + i - 1][1], k)
	// 	S[nInputs + i] = feistelRes
	// 	outs[i + 1] = S[nInputs + i][0]
	// endfor 

	return outs

def mimc_4(field[4] ins) -> field:
	field nInputs = 4
	field[3][2] S = [[0; 2]; 3] // Dim: (nInputs + nOutputs - 1, 2)

	for field i in 0..nInputs do
		field idx = if i == 0 then 0 else i - 1 fi
		S[i] = if i == 0 then MiMCFeistel(ins[0], 0, 0) else MiMCFeistel(S[idx][0] + ins[i], S[idx][1], 0) fi
	endfor
	return S[nInputs - 1][0]

def main(Balance[3] balances) -> (field[3]):
	field[3] res = [0,0,0]
	for field i in 0..3 do
		field addrs = pack256(u32_8_to_bool_256([...balances[i].address, 0x00000000, 0x00000000, 0x00000000]))
		field temp = mimc_4([addrs, balances[i].ethAmount, balances[i].tokenAmount, balances[i].nonce])
		res[i] = temp
	endfor
	return res


// def mimc_5(field[5] ins) -> field:
// 	field nInputs = 5
// 	field[4][2] S = [[0; 2]; 4] // Dim: (nInputs + nOutputs - 1, 2)

// 	for field i in 0..nInputs do
// 		field idx = if i == 0 then 0 else i - 1 fi
// 		S[i] = if i == 0 then MiMCFeistel(ins[0], 0, k) else MiMCFeistel(S[idx][0] + ins[i], S[idx][1], k) fi
// 	endfor
// 	return S[nInputs - 1][0]


def hashPair(bool[256] a, bool[256] b) -> (bool[256]):
	return if pack128(a[0..128]) <= pack128(b[0..128]) then sha256(a, b) else sha256(b, a) fi

def hashPairNoPack(bool[256] a, bool[256] b, field c) -> (bool[256]):
	return if 1 == c then sha256(a, b) else sha256(b, a) fi

def hashPairNon(bool[256] a, bool[256] b) -> (bool[256]):
	return if pack128(a[0..128]) <= pack128(b[0..128]) then a else b fi

def hashPairNonNon(bool[256] a, bool[256] b) -> (bool[256]):
	return a

def hashPairMimc(bool[256] a, bool[256] b) -> (bool[256]):
	return if pack128(a[0..128]) <= pack128(b[0..128]) then sha256(a, b) else sha256(b, a) fi

def getPosition(bool proofFlag, field leafPos, field leafsLen) -> (field):
	return if proofFlag then if leafPos < leafsLen then 0 else 1 fi else 2 fi

// def main(bool[256] a, bool[256] b) -> (bool[256]):
// 	return if pack128(a[0..128]) <= pack128(b[128..256]) then sha256(a, b) else sha256(b, a) fi

def mimcHashPair(field a, field b) -> (field):
	return if a > b then mimc([a, b], 0) else mimc([b, a], 0) fi





	// FC43A192F7CB684A1E7CB043AAC166A2E50741B2776F71E16B047C17377B4315

def main(field[90] leafs, field[90] proofs, bool[90] proofFlags) -> (field):
	field leafsLen = 3
	field totalHashes = 90
	field[90] hashes = [0;90]
	field[3] indexes = [0, 0, 0] // 0: leafPos, 1: hashPos, 2: proofPos
	for field i in 0..totalHashes do
		field[3] nodes = [leafs[indexes[0]], hashes[indexes[1]], proofs[indexes[2]]]
		field aPos = getPosition(proofFlags[i], indexes[0], leafsLen)
		field a = nodes[aPos]
		indexes[aPos] = indexes[aPos] + 1

		nodes = [leafs[indexes[0]], hashes[indexes[1]], proofs[indexes[2]]]
		field bPos = getPosition(true, indexes[0], leafsLen)
		field b = nodes[bPos]
		indexes[bPos] = indexes[bPos] + 1
		field hash = mimcHashPair(a, b)
		hashes[i] = hash
	endfor
	return hashes[totalHashes - 1]


// Benchmarking tree verification:
// Normal: 2176276
// No hashing: 1178032
// no hashing, no packing: 228829
// hash, no pack: 1231683
// mimcField hash: 109110


// Benchmarking 90 trade updates:



// Benchmarking hashing op:
// sha, bin, sort: 217151
// mimc, field, sort: 8181
// however: 442773 gas for one inclusion proof


//Entire implementation:
//sha: 6751986
// mimc/sha for final: 550628




