import "EMBED/unpack" as unpack
import "hashes/sha256/embed/512bitPadded" as sha256
import "utils/casts/u32_8_to_bool_256.zok" as u32_8_to_bool_256
import "utils/pack/bool/pack128.zok" as pack128
import "hashes/sha256/embed/1024bitPadded" as sha256_4
import "utils/pack/bool/nonStrictUnpack256.zok" as field_to_bool




struct Balance {
	field ethAmount
	field tokenAmount
	field nonce
	u32[5] address
}	

def field_to_64bit(field i) -> bool[64]:
    bool[254] b = unpack(i)
    assert(b[0..190] == [false; 190])
    return b[190..254]



// def main() -> (field[2]):
// 	Balance bal = Balance{ethAmount: 1, tokenAmount: 1, nonce: 1, address: [0x31b87891, 0x8679d9DA, 0x1DB277B1, 0xA2fD67Aa, 0x01032920]}
// 	bool[256] addrs = u32_8_to_bool_256([0x31b87891, 0x8679d9DA, 0x1DB277B1, 0xA2fD67Aa, 0x01032920, 0x00000000, 0x00000000, 0x00000000])
// 	bool[256] amounts = [...field_to_64bit(bal.ethAmount), ...field_to_64bit(bal.tokenAmount), ...field_to_64bit(bal.nonce), ...field_to_64bit(0)]
// 	bool[256] res = sha256(addrs, amounts)
// 	return [pack128(res[0..128]), pack128(res[128..256])]
	// 0x0000000000000000000000000000000000000000000000000000000000000001

def hashLeafs(Balance[3] balances) -> (bool[3][256]):
	bool[3][256] res = [[false;256];3]
	for field i in 0..3 do
		bool[256] addrs = u32_8_to_bool_256([...balances[i].address, 0x00000000, 0x00000000, 0x00000000])
		bool[256] amounts = [...field_to_64bit(balances[i].ethAmount), ...field_to_64bit(balances[i].tokenAmount), ...field_to_64bit(balances[i].nonce), ...field_to_64bit(0)]
		bool[256] temp = sha256(addrs, amounts)
		res[i] = temp
	endfor
	return res

def main() -> (field[2]):
	Balance[3] balances = [Balance{ethAmount: 22555186049, tokenAmount: 0, nonce: 2, address: [0xcc08e563, 0x6A9ceb03, 0x917C1ac7, 0xBbEda23a, 0xD57766F3]},Balance{ethAmount: 5000000000, tokenAmount: 44335701680000, nonce: 2, address: [0x31b87891, 0x8679d9DA, 0x1DB277B1, 0xA2fD67Aa, 0x01032920]},Balance{ethAmount: 0, tokenAmount: 21841427940000, nonce: 2, address: [0x1D539b71, 0x7035B802, 0x40d6e783, 0x6B2C752E, 0x204B7DD4]}]
	bool[3][256] leafs = hashLeafs(balances)
	bool[256] oldRoot = u32_8_to_bool_256([0xc46969cc, 0xa8d50452, 0x9c5a1fe1, 0x3d671899, 0xac013358, 0xfc905d35, 0xc8da396a, 0xc878684a])
	bool[256] newRoot = u32_8_to_bool_256([0x98432d17, 0x299b437d, 0xa6418d23, 0xb95555c6, 0x0713d111, 0x839876b9, 0x6a0a8bfe, 0x97bf55d0])
	bool[256] rootPrice = sha256_4(oldRoot, newRoot, [...field_to_64bit(1000000000000), ...field_to_64bit(2216785084000000), ...field_to_64bit(0), ...field_to_64bit(0)], field_to_bool(0))
	bool[256] res = sha256_4(leafs[0], leafs[1], leafs[2], rootPrice)

	return [pack128(res[0..128]), pack128(res[128..256])]




// // A function that takes 6 bool[256] arrays as inputs
// // and applies 3 rounds of sha256 compression.
// // It returns an array of 256 bool.
// def main(bool[256] a, bool[256] b, bool[256] c, bool[256] d, bool[256] e, bool[256] f) -> (bool[256]):

//     bool[256] IV = IVconstants()
//     bool[256] digest1 = sha256(a, b, IV)
//     bool[256] digest2 = sha256(c, d, digest1)
//     bool[256] digest3 = sha256(e, f, digest2)

//     return digest3