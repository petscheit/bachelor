import "hashes/sha256/embed/512bitPadded" as sha256
import "hashes/sha256/embed/1024bit" as sha256_4
import "utils/casts/u32_to_field" as to_field
import "utils/pack/bool/nonStrictUnpack256.zok" as field_to_bool
import "utils/pack/u32/nonStrictUnpack256" as to_u32_8
import "utils/casts/u32_8_to_bool_256.zok" as u32_8_to_bool
import "utils/casts/bool_256_to_u32_8.zok" as bool_to_u32_8
import "utils/pack/bool/pack128.zok" as pack128
import "utils/pack/bool/unpack128.zok" as unpack128

struct Balance {
	field ethAmount
	field tokenAmount
	field nonce
	u32[5] address
}

// route eth->token: 1000000000000000000 -> 2260641686129749542390
// 	tokenPrice: 1000000000000000000 / 2260641686129749542390 = 0,0004423522782
// 	ethPrice: 2260641686129749542390/1000000000000000000 = 2260,6416861297

// token -> eth: 1000000000000000000 -> 419516425224156
// 	tokenPrice: 419516425224156/1000000000000000000 = 0,0004195164252
// 	ethPrice: 1000000000000000000/419516425224156 = 2383,6968945034


// 21000000000

def main() -> (field, field, field, field, field):
	// Balance[3] oldBalances = [Balance{ethAmount:0,tokenAmount:100000000000000,nonce:1,address:[0xcc08e563,0x6A9ceb03,0x917C1ac7,0xBbEda23a,0xD57766F3]},Balance{ethAmount:100000000000,tokenAmount:100000000000000,nonce:2,address:[0x31b87891,0x8679d9DA,0x1DB277B1,0xA2fD67Aa,0x01032920]},Balance{ethAmount:10000000000,tokenAmount:0,nonce:1,address:[0x4d9b01D7,0x11c90883,0x3f97ea78,0xCF2AE0C7,0x74607a4d]}]

	// Balance[3] newBalances = [Balance{ethAmount:21000000000,tokenAmount:50000000000000,nonce:2,address:[0xcc08e563,0x6A9ceb03,0x917C1ac7,0xBbEda23a,0xD57766F3]},Balance{ethAmount:90000000000,tokenAmount:122606416860000,nonce:3,address:[0x31b87891,0x8679d9DA,0x1DB277B1,0xA2fD67Aa,0x01032920]},Balance{ethAmount:0,tokenAmount:22606416860000,nonce:2,address:[0x4d9b01D7,0x11c90883,0x3f97ea78,0xCF2AE0C7,0x74607a4d]}]

	Balance[3] oldBalances = [Balance{ethAmount:100000000000,tokenAmount:10000000000000,nonce:2,address:[0xcc08e563,0x6A9ceb03,0x917C1ac7,0xBbEda23a,0xD57766F3]},Balance{ethAmount:100000000000,tokenAmount:0,nonce:1,address:[0x31b87891,0x8679d9DA,0x1DB277B1,0xA2fD67Aa,0x01032920]},Balance{ethAmount:0,tokenAmount:50000000000000,nonce:1,address:[0x4d9b01D7,0x11c90883,0x3f97ea78,0xCF2AE0C7,0x74607a4d]}]
	
	Balance[3] newBalances =  [Balance{ethAmount:100423922055,tokenAmount:9000000000000,nonce:3,address:[0xcc08e563,0x6A9ceb03,0x917C1ac7,0xBbEda23a,0xD57766F3]},Balance{ethAmount:90000000000,tokenAmount:22376834588242,nonce:2,address:[0x31b87891,0x8679d9DA,0x1DB277B1,0xA2fD67Aa,0x01032920]},Balance{ethAmount:4239220550,tokenAmount:40000000000000,nonce:2,address:[0x4d9b01D7,0x11c90883,0x3f97ea78,0xCF2AE0C7,0x74607a4d]}]

	field baseAmount = 1000000000000
	field ethToToken = 22376834588242
	field tokenToEth = 423922055

	field boughtEth = 0
	field soldEth = 0
	field boughtToken = 0
	field soldToken = 0
	field left = 0
	field right = 0
	for field i in 0..1 do
		assert(oldBalances[i].nonce == newBalances[i].nonce - 1) // makes sure the nonce is incremented
		field tradeDirection = if oldBalances[i].ethAmount >= newBalances[i].ethAmount then 0 else 1 fi
		field deltaEth = if tradeDirection == 0 then oldBalances[i].ethAmount - newBalances[i].ethAmount else newBalances[i].ethAmount - oldBalances[i].ethAmount fi
		field deltaToken = if tradeDirection == 0 then newBalances[i].tokenAmount - oldBalances[i].tokenAmount else oldBalances[i].tokenAmount - newBalances[i].tokenAmount fi
		boughtEth = if tradeDirection == 1 then boughtEth + deltaEth else boughtEth fi
		soldEth = if tradeDirection == 0 then soldEth + deltaEth else soldEth fi
		boughtToken = if tradeDirection == 0 then boughtToken + deltaToken else boughtToken fi
		soldToken = if tradeDirection == 1 then soldToken + deltaToken else soldToken fi
		left = baseAmount * deltaEth
		right = tokenToEth * deltaToken
		assert(ethToToken * deltaEth == 10000000000 * deltaToken && tradeDirection == 0 || 1000000000000 * deltaEth == tokenToEth * deltaToken && tradeDirection == 1) // this works with 64 bit numbers, anything higher will overflow. Maybe check this somewhere?
	endfor
	//                                    +Eth, -Token | -Eth, +Token
	field direction = if boughtEth > soldEth then 1 else 0 fi
	field deltaEth = if direction == 1 then boughtEth - soldEth else soldEth - boughtEth fi
	field deltaToken = if direction == 0 then boughtToken - soldToken else soldToken - boughtToken fi
	return direction, deltaEth, deltaToken, left, right