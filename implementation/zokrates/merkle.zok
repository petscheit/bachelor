import "hashes/sha256/512bitPadded" as sha256
import "hashes/sha256/1024bitPadded" as sha256_4
import "utils/casts/u32_to_field" as to_field
import "utils/pack/u32/nonStrictUnpack256" as to_u32_8

struct Trade {
        field ethAmount 
        field tokenAmount 
        field nonce
        field deltaEth
        field deltaToken
        field direction // 0: -eth, +token  1: -token, +eth
}

struct Balance {
        field ethAmount
        field tokenAmount
        field nonce
}

def computeMerkle(u32[2][8] proof, u32[8] leaf) -> u32[8]:
	u32[8] computedHash = leaf
	for field i in 0..2 do
                computedHash = if to_field(computedHash[0]) <= to_field(proof[i][0]) then sha256(computedHash, proof[i]) else sha256(proof[i], computedHash) fi
        endfor
	return computedHash 
// Question:
// Is it sound logic that the first u32 of a hash result decides which one is larger? I think since the integers are to be concatted later and the 


// Since I'm not able to use asserts in if-else construct this is the way to do it. 
def checkEthSell(Trade trade) -> Balance: 
        bool valid = true
        valid = valid && trade.ethAmount >= trade.deltaEth
        valid = valid && trade.tokenAmount <= trade.deltaToken
        Balance res = if valid \
                then Balance { ethAmount: trade.ethAmount - trade.deltaEth, tokenAmount: trade.tokenAmount + trade.deltaToken, nonce: trade.nonce + 1 } \ // returns new balance
                else Balance { ethAmount: trade.ethAmount, tokenAmount: trade.tokenAmount, nonce: trade.nonce } fi // returns old balance if trade is not vaild
        return res

def checkTokenSell(Trade trade) -> Balance:
        bool valid = true
        valid = valid && trade.ethAmount <= trade.deltaEth
        valid = valid && trade.tokenAmount >= trade.deltaToken
        Balance res = if valid \
                then Balance { ethAmount: trade.ethAmount + trade.deltaEth, tokenAmount: trade.tokenAmount - trade.deltaToken, nonce: trade.nonce + 1 } \
                else Balance { ethAmount: trade.ethAmount, tokenAmount: trade.tokenAmount, nonce: trade.nonce } fi
        return res

def hashBalance(field etherAmount, field tokenAmount, field nonce) -> u32[8]:
	u32[8] padding = [0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000]
	return sha256_4(to_u32_8(etherAmount), to_u32_8(tokenAmount), to_u32_8(nonce), padding)


def main() -> Balance:
        u32[2][8] proof = [[0x38723a2e,0x5e8a17aa,0x7950dc00,0x8209944e,0x898f69a7,0xbd10a23c,0x839d341e,0x935fd5ca], [0xa43aa6b3,0xc453fcd7,0x89237756,0x1bf9dd95,0x1ec81bdf,0x6622d07f,0x5cc4f707,0x49cc8598]]
        // u32[8] root = [0x477076ae,0xafdb714b,0x192777b7,0x70ecb909,0xea1a7fa9,0xdb8dc3b5,0x944eb392,0xf23b6753] // empty root
        u32[8] root = [0xc0e449f3, 0x886318a6, 0x170495b7, 0x18fd40b6, 0xc4afdcae, 0x3317531d, 0x0948b065, 0x2cf74ca7] // 10 eth 2nd wallet deposited
        Trade trade = Trade {ethAmount: 10000000000000000000, tokenAmount: 0, nonce: 0, deltaEth: 5000000000000000000, deltaToken: 1000, direction: 1}
        assert(computeMerkle(proof, hashBalance(trade.ethAmount, trade.tokenAmount, trade.nonce)) == root) // checks if passed balance is correct
        Balance newBalance = if trade.direction == 0 then checkEthSell(trade) else checkTokenSell(trade) fi
        return newBalance
 

// Root Balances:  0xc0e449f3886318a6170495b718fd40b6c4afdcae3317531d0948b0652cf74ca7
// ["0x38723a2e5e8a17aa7950dc008209944e898f69a7bd10a23c839d341e935fd5ca","0xa43aa6b3c453fcd7892377561bf9dd951ec81bdf6622d07f5cc4f70749cc8598"], 10000000000000000000, 0, 0
